# TIL (Today I Learned)

## 날짜: 2025-02-05

### 스크럼
- 어제 한 일 : CLI 과제 마무리(클래스 다이어그램 작성) 및 제출, 이번주 계획 세우기
- 오늘 할 일 : 스레드랑 클래스 아키텍처 키워드 정리, 기술+회고 블로그 작성
- 무드미터 : '편안한' - 어제보다는 덜 피곤한 상태

### 새로 배운 내용
#### 블로킹 / 논블로킹
- **블로킹:** 현재의 작업이 끝나고 다음 작업을 시작하는 것
  - 블로킹은 작업이 순서대로 진행하는 것은 보장하지만 효율성이 떨어진다.
- **논블로킹:** 현재의 작업이 끝나지 않아도 다음 작업을 시작하는 것
  - 논블로킹은 작업의 순서에 상관없이 앞 작업이 끝나지 않아도 각자의 업무를 진행하기 때문에 효율성이 높다.
- 즉, 블로킹과 논블로킹은 서로의 작업에 **차단**을 하는지 안하는지로 구분한다.
- **[제어권 관점에서의 블로킹 / 논블로킹의 차이점]**
  - 블로킹은 제어권을 완전히 넘기는 것이다. 따라서 제어권이 넘어갔기 때문에 다른 작업을 진행할 수 없다. 반면 논블로킹은 제어권을 잠깐 넘겨주지만 바로 돌려 받는다. 따라서 작업이 진행되는 동안에도 백그라운드에서는 다른 작업을 진행할 수 있다.
  - [파일 읽기 작업 예시 설명]
    - 블로킹 방식에서는, 파일 읽는 메소드 호출 시에 제어권이 파일 시스템에게 넘어간다. 따라서 다른 작업을 수행할 수 없고, 파일 읽기가 완료되면 제어권이 반환되어 다음 작업을 할 수 있다.
      논블로킹 방식에서는, 파일 읽는 메소드 호출 시에 제어권을 넘겼다가 실행되면 바로 반환한다. 제어권을 반환받았기 때문에 파일을 읽는 동안 다른 작업을 수행할 수 있다. 파일 읽기가 끝나면 callback을 호출한다.

#### 동기 / 비동기
- **동기:** 현재 작업이 끝나야만 다음 단계의 작업으로 넘어간다.
- **비동기:** 서로의 작업이 독립적으로 진행됨. 작업이 완료되면 서로에게 알림을 준다.
    - 비동기 방식은 작업 완료를 기다리는 시간을 줄이고 CPU 자원을 최대한 활용 가능하다.
- 비동기는 언제 어디서 문제가 생긴 것인지 찾기 어렵다. 따라서 순차적인 작업으로 흐름을 파악해야 할 때는 동기 방식을 사용한다.
- **[동기 / 비동기의 차이]**
    - 동기는 작업의 실행 순서가 보장되며, 프로그램의 흐름을 이해하기가 쉽다. 하지만 작업 시간이 오래 걸릴 수 있다. 반면 비동기는 실행 순서는 보장되지 않지만 CPU 자원의 효율적인 사용과 여러 작업을 동시에 처리할 수 있어서 실시간 처리 시스템에 적합하다.
    - [파일 읽기 작업 예시 설명]
        - 동기 방식으로 파일을 읽으면, 파일을 읽기 시작한 이후에 다음 코드를 실행하지 않고 파일을 다 읽을 때까지 기다린다. 반면 비동기 방식으로 파일을 읽으면 파일을 읽는 작업이 실행되는 동안 다른 작업을 수행할 수 있다. 비동기 방식은 백그라운드에 ‘해당 파일을 읽을 것’이라는 요청만 보내고 바로 다음 작업을 하러 간다. 파일 읽기가 완료되면 백그라운드는 다시 메인 스레드에 읽기가 완료되었음을 알린다.

#### 추가 정리
- **[동기 + 블로킹과 동기 + 논블로킹 조합의 차이]**
    - 동기+블로킹은 제어권과 결과 처리 순서가 동일한 방식이다. 앞 작업이 완전히 끝나야만 다음 작업을 시작할 수 없다. 따라서 각 단계의 결과가 다음 단계의 시작을 결정하게 되고, 제어권도 이 결과 처리를 따라 같이 넘어간다.
    - 동기+논블로킹에서는, 제어권은 작업 실행 후 즉시 반환되고 뒷 작업의 시작은 앞 작업이 결과를 완료하는 시점에 결정된다. 앞 작업은 뒷 작업을 기다리지 않고 계속해서 진행하며, 뒷 작업은 앞 작업을 기다리진 않지만 작업 시작 시점은 앞 작업이 결과를 전달하는 시점에 동기적으로 결정된다.
- **[비동기 I/O와 논블로킹 I/O는 같은 개념인가? 두 개념의 다른 점?]**
    - 비동기 I/O는 I/O 처리가 완료된 타이밍으로 결과를 회신한다. 회신은 시그널 또는 콜백의 형태로 이루어지며 회신이 있을 때까지 다른 작업을 수행할 수 있다. 프로세스가 차단 상태가 되지 않는다는 점에서는 논블로킹 I/O와 같지만, 비동기의 경우 I/O 처리를 완료했을 때 통지를 하고, 처리를 바로할 수 없는 경우 처리가 완료될 때까지 백그라운드에서 대기하고 종료한 타이밍을 화신하는 반면, 논블로킹은 처리가 완료되지 않으면 에러를 회신한다. 논블로킹 I/O는 호출 직후 바로 제어권이 반환되기 때문에 다음 작업을 진행할 수 있다.


### 오늘의 도전 과제와 해결 방법
- 멀티 스레드 환경에서 블로킹 I/O를 사용할때 발생하는 컨텍스트 스위칭 오버헤드를 줄이기 위한 방법은 어떤 것이 있나?
- 웹 서버 아키텍처에서 논블로킹 방식이 주는 성능적 이점은 무엇인가?


### 오늘의 회고
- 동기/비동기와 블로킹/논블로킹에 대해서 그동안 단어만 들어보고 제대로 공부해본 적은 없었는데 
이번 기회로 자세하게 배울 수 있어서 좋았다. 여전히 이해가 안가는 부분이 많지만 추가적으로 공부를 하면서
더 알아가야할 것 같다. 케빈이 오늘 배운 개념들은 한번에 이해가 되기 어렵다고 하셨으니 완벽히 이해를 하려면 꾸준히 공부를 해야할 것 같다!
그리고 이해가 되어도 설명하기가 어려운 개념이라고 하니까 여러번 공부를 해봐야겠다.

### 참고 자료 및 링크