# TIL (Today I Learned)

## Date: 2025-02-13 (Day 14)

### Daily Scrum
- [What I did Yesterday] <br>
2주차 과제 README랑 회고 자세하게 적어서 제출 <br>
2/11, 2/12 TIL 작성 → 근데 어제(2/12) 내용은 키워드 정리를 못해서 다는 못함..
- [What to do Today] <br>
어제 키워드 내용 정리 <br>
오늘 내용 TIL
- [Mood Meter] <br>
  `거슬리는`→ 유지장치가 떨어져서 치과를 가야하는데 아직 못가서 상당히 불편한 상태..악
  <br>`재미있는`→ 오늘 처음으로 교육장을 나왔는데, 나오니까 아주 상쾌하다~

### New things I learned
#### Today's Timeline
- 9am-10am: Daily Scrum
- 10am-12pm: HTTP 자격증명 헤더, JWT 강의
- 1pm-1:30pm: OAuth 강의
- 1:30pm-3pm: Weekly Challenge
- 3pm-4pm: Weekly Challenge & 후기 작성
- 4pm-6pm: 카카오 크램폴린 IDE QnA & Weekly Challenge
- 6pm-After: 자율 학습

#### Lesson: HTTP 자격증명 헤더, JWT, OAuth
|                                       | 정의                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | 비고                                                                                                                                                                                  |
|---------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| HTTP 자격증명 헤더                          | 클라이언트가 서버에 요청을 보낼 때, 인증 정보를 포함하는 헤더                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | - HTTP 자격증명 헤더를 통해 서버는 요청을 보낸 사용자의 신원을 확인할 수 있다.                                                                                                                                    |
| - WWW-Authenticate 헤더                 | 서버가 클라이언트에게 인증이 필요함을 알리는 역할                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | `401 Unauthorized` 응답과 함께 제공됨                                                                                                                                                       |
| - Authorization 헤더                    | 클라이언트가 인증 정보를 서버에 제공하는 헤더                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | WWW-Authentication 헤더에서 요구한 인증 방식을 따름                                                                                                                                               |
| Bearer Token                          | OAuth 2.0 및 JWT 인증에서 사용된다. 토큰 기반 인증으로 비밀번호를 직접 전송하지 않는다.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | 클라이언트가 서버로부터 액세스 토큰을 받아 요청 시에 포함하여 인증을 수행한다. <br> [요청 예시] <br> ”`Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...`" <br> :”`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9…`" 부분은 JWT 토큰 값 |
| JSON Web Token (JWT)                  | 인증 정보를 JSON 형태로 암호화하여 토큰으로 만든 다음, 해당 토큰을 클라이언트에게 전달하는 방식                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | - 사용자의 세션 상태를 유지하거나 사용자 인증에 사용된다.- JWT 토큰에는 사용자의 인증 정보뿐만 아니라 필요한 추가 정보(클레임(Claim))도 함께 포함될 수 있다. <br> - 클라이언트가 서버에 요청을 보낼 때, 해당 JWT 토큰을 함께 전송하여 서버가 해당 사용자의 인증 정보를 확인하고 인가를 수행하게 된다.|
| - JWT 구조 (Header, Payload, Signature) | **[Header]** <br> Header JWT 토큰의 헤더에는 토큰이 어떤 종류의 토큰인지를 나타내는 “typ” 필드와 사용된 암호화 알고리즘을 나타내는 “alg”라는 필드가 포함된다. → 이 정보들은 Base64로 인코딩 되어 있음. <br>**[Payload]** <br> Payload JWT 토큰의 페이로드에는 사용자 정보와 같은 클레임(Claim) 정보들이 들어간다. 클레임 정보는 이름과 값으로 구성되어 있으며 JWT에서는 미리 정의된 registered, public, private이라는 3가지 종류의 클레임을 사용할 수 있음. 각각의 클레임은 다양한 정보를 담을 수 있다. → Payload도 Base64로 인코딩 되어 있음.<br>**[Signature]** <br> Signature JWT 토큰의 signature는 Header와 Payload를 합쳐서 암호화하는데 사용된다. 암호화 알고리즘은 Header에서 지정된 알고리즘을 따륻나. 이러한 Signature는 헤더와 페이로드가 조작되지 않았다는 것을 검증하는 역할을 함!                                                                                                                                                                                                                                     | 참고 링크: https://develop-const.tistory.com/14 |
| - JWT 서명 및 암호화 (HMAC, RSA, ECDSA)     | JWT에서는 서명과 암호화 기법을 적용하여 보안을 강화한다. <br> 서명 → 변조를 방지하여 무결성을 보장. 서명된 JWT는 검증을 통해 유효성 확인이 가능. <br> 암호화 → 데이터 내용을 보호하여 기밀성을 보장. JWT의 내용을 암호화하여 디코딩 불가 상태로 만든다. <br> ⚠ JWT는 일반적으로 서명만 적용하며 암호화는 추가적으로 필요할 때만 사용한다.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | <JWT의 서명 알고리즘> <br> 1. HMAC (HS256, HS384, HS512) <br> - 대칭키 암호화 방식 <br> - 비밀키를 기반으로 해시를 생성해서 토큰을 서명한다. <br> - 빠르고 간단하지만 키 공유의 문제가 있다. <br> - 보안성이 취약하기 때문에 내부 시스템에서 서버 간 인증이 필요한 경우 정도에만 사용함. (ex. 마이크로 서비스) <br> 2. RSA (RS256, RS384, RS512) <br> - 비대칭키 암호화 방식 <br> - 보안성이 뛰어나고 키 관리가 용이 <br> - HMAC 보다는 느림 <br> - 여러 시스템에서 안전하게 인증 가능 (OAuth 2.0, OpenID Connect 사용) <br> 3. ECDSA (ES256, ES384, ES512) <br> - 비대칭키 암호화 방식 <br> - RSA보다 짧은 키 길이로 동일한 보안성을 제공함. <br> - 속도와 보안성이 우수하기 때문에 모바일이나 IoT 환경에서 선호됨. |
| - 세션 기반 인증과의 비교                       | JWT는 클라이언트 측에서 토큰을 저장하고, 이를 통해 인증을 처리하는 방식이다. 반면, 세션 기반 인증은 서버 측에서 세션을 관리하고, 클라이언트는 세션 ID를 통해 인증을 처리한다.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | 세션은 사용자의 민감한 정보(인증 정보)가 브라우저(클라이언트)가 아닌 서버에 저장하고 관리한다. 그렇기 때문에 서버가 사용자의 상태를 저장하고 있어야 하는데 이는 stateful한 방식이며 서버에 부담이 된다. 이러한 한계를 극복하기 위한 방식이 토큰 방식인 JWT이다. JWT에서는 인증에 필요한 정보들을 암호화시킨 JSON 토큰을 클라이언트에 저장한다. 서버가 클라이언트의 상태를 저장하지 않기 때문에 stateless하여 서버의 부담이 적다. <br> *참고 링크: [https://hstory0208.tistory.com/entry/JWT란-장단점과-Session-인증-방식과의-차이점을-알아보자](https://hstory0208.tistory.com/entry/JWT%EB%9E%80-%EC%9E%A5%EB%8B%A8%EC%A0%90%EA%B3%BC-Session-%EC%9D%B8%EC%A6%9D-%EB%B0%A9%EC%8B%9D%EA%B3%BC%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%84-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90) |
| Access Token / Refresh Token          | - Access Token은 사용자가 인증되었음을 증명하는 단기 유효 토큰이다. API 요청 시에 사용되며, 서버가 클라이언트의 권한을 확인하는 데 필요함. <br> - Refresh Token은 Access Token이 만료되었을 때 새로운 Access Token을 발급받는 용도로 사용하며 유효기간이 길다.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |  |
| OAuth 2.0                             | 인증을 위한 개방형 표준 프로토콜 → Third Party 프로그램(제 3자 애플리케이션)이 리소스 소유자(사용자)를 대신하여 리소스 서버에서 제공하는 자원에 대한 접근 권한(HTTP 서비스 이용 권한)을 부여하는 방식을 제공함.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | - 이 프로토콜은 사용자의 로그인 정보를 제 3자 앱이나 웹 사이트와 공유하지 않고도, 해당 앱이나 웹사이트가 사용자 대신에 특정 작업을 수행하도록 허용한다. <br> 참고링크: https://blog.naver.com/mds_datasecurity/222182943542 <br> [https://velog.io/@jy3026/OAuth2.0란-무엇인가](https://velog.io/@jy3026/OAuth2.0%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80) |
| - OAuth 1.0과의 차이점                     | 1. OAuth 1.0에서는 토큰을 갱신하는게 어려웠지만, 2.0에서는 새로운 토큰을 쉽게 발급하고 갱신할 수 있다. <br> 2. OAuth 1.0에서는 서명된 요청을 사용하여 사용자를 인증하지만, 2.0에서는 보안 토큰을 사용하여 인증한다. <br> 3. OAuth 2.0은 보다 범용적인 프로토콜이며 모바일 기기 등의 다양한 플랫폼에서 사용 가능하지만, 1.0은 덜 유연하고 웹 기반 애플리케이션에서 주로 사용된다. <br> 4. OAuth 1.0은 두 단계 승인 절차를 사용하지만, 2.0은 좀 더 단순한 승인 절차를 사용한다.                                                                                                                                                                                                                                           | 참고 링크: [https://canada-coder.tistory.com/entry/잡-인터뷰-2-OAuth-10-과-OAuth-20의-차이점](https://canada-coder.tistory.com/entry/%EC%9E%A1-%EC%9D%B8%ED%84%B0%EB%B7%B0-2-OAuth-10-%EA%B3%BC-OAuth-20%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90) |
| 보안 강화 대책 (XSS, CSRF, 토큰 탈취 방지)        | XSS는 공격자가 웹사이트에 악성 스크립트를 삽입하여 피해자의 브라우저에서 실행되도록 하는 공격 → 방어대책: 입력값 검증 및 이스케이프 처리, CSP 적용 <br> CSRF는 공격자가 피해자의 브라우저를 이용해 의도하지 않은 요청을 특정 웹사이트에 보내도록 유도하는 공격 → 방어대책: CSRF 토큰, SameSite 쿠키 설정, CORS 제한 <br> 토큰 탈취는 사용자의 인증 정보를 공격자가 가로채어 권한을 탈취하는 공격. 토큰이 탈취되면 공격자는 해당 사용자의 세션을 가로챌 수 있다. → 방어대책: HTTPS 사용, HttpOnly & Secure 쿠키, 짧은 만료 시간, 2FA 적용                                                                                                                                                                                                                                                                                                                                                                                                                                             |  |


### 예시 질문

#### - HTTP 자격증명 헤더가 웹 어플리케이션 보안에서 어떤 역할을 하는지 설명해주세요

HTTP 자격증명 헤더는 클라이언트가 서버에 인증 정보를 제공하는 데 사용된다. 이를 통해 서버는 요청을 보낸 사용자의 신원을 확인하고 적절한 권한을 부여할 수 있다.

[기본 형식]

```
Authorization: <type> <credentials>
```

- `<type>`: 인증 방식 (`Basic`, `Bearer`, `Digest` 등)
- `<credentials>`: 인증 정보 (Base64 인코딩, JWT 토큰, 해시 값 등)

**[웹 애플리케이션 보안에서 HTTP 자격증명 헤더의 역할]**

1. 사용자 인증 (Authentication)
  - 누가 요청을 보냈는지 확인하는 역할
  - 사용자가 로그인하면 클라이언트는 `Authorization` 헤더를 포함하여 요청을 전송.
  - 서버는 이 정보를 검증하여 사용자의 신원을 확인
  - (ex) JWT 기반 인증에서 서버는 JWT 토큰을 검증하여 사용자가 누구인지 확인 후 응답을 보냄.
2. 요청 권한 부여 (Authorization)
  - 사용자의 역할과 권한 체크
  - 인증이 성공한 사용자라도 특정 리소스에 접근할 권한이 있는지 확인해야 함.
  - (ex) RBAC (Role Based Access Control)에서 서버는 Authorization 헤더의 정보를 기반으로 사용자의 역할을 확인한 후, 요청을 허용 또는 차단함.
3. API 및 마이크로서비스 보호
  - API 엔드포인트 보호를 위해 API key 또는 JWT를 사용하여 인증 수행
  - MSA 아키텍처에서는 서비스 간 요청을 보호하는 데도 사용됨.
  - (ex) API Key에서 서버는 API Key가 유효한지 확인 후 요청을 처리함.
4. 보안 강화 (Replay Attack 방지, Rate Limiting)
  - HTTP 자격증명 헤더를 기반으로 추가적인 보안 정책을 적용 가능
  - Replay Attack 방지: nonce (한번만 사용 가능한 값) 또는 timestamp를 포함하여 재사용 방지
  - (ex) Digest Authentication에서 nonce를 사용하는 경우, 서버는 nonce를 검증하여 동일 요청의 반복 제출을 차단함.
5. HTTPS와 함께 사용하여 보안 강화
  - HTTP 자격증명 헤더는 평문으로 전송되므로, 반드시 HTTPS와 함께 사용해야 함.
  - HTTPS를 사용하지 않으면 중간자 공격(MITM, Man-in-the-Middle)에 취약해짐.

**[최종 정리: HTTP 자격증명 헤더 보안 고려 사항]**

| 보안 이슈 | 해결 방법 |
| --- | --- |
| 토큰 탈취 위험 | HTTPS 필수 사용 (암호화된 통신 보장) |
| 토큰 유효기간 관리 | Access Token을 짧게 설정하고 Refresh Token 사용 |
| 토큰 재사용 공격 방지 | nonce, timestamp, IP 바인딩 활용 |
| 토큰 저장 위치 보안 | 로컬 스토리지 X → 메모리 또는 HTTP-Only Secure Cookie 사용 |
| API Rating Limiting | 특정 IP, 사용자별 요청 제한 적용 |
| 로그아웃 시 토큰 폐기 | 서버에서 Refresh Token을 삭제하여 사용 중지 |

---

[주요 인증 방식]

1. Basic Authentication (기본 인증)
  - 가장 간단한 인증 방식으로 `username:password`를 Base64로 인코딩하여 전송함.
  - 보안이 취약하므로 HTTPS를 반드시 사용해야 함.
  - Base64는 단순한 인코딩일 뿐 암호화가 아님! 네트워크에서 쉽게 탈취 가능.
2.  Bearer Token (토큰 기반 인증)
  - OAuth 2.0 및 JWT에서 사용됨.
  - 클라이언트가 서버로부터 액세스 토큰을 받아 요청 시 포함하여 인증을 수행함.
  - 장점: 비밀번호를 직접 전송하지 않음. 한번 발급된 토큰을 여러 API 요청에서 재사용 가능
  - 단점: 토큰이 탈취되면 해당 사용자의 권한을 도용할 수 있으므로 토큰 보호 필요. 일반적으로 만료시간을 설정하여 보안을 강화함.
3. Digest Authentication (다이제스트 인증)
  - Basic 인증보다 보안이 강화된 방식
  - 비밀번호를 직접 전송하는 게 아니라 해시값(HMAC)을 이용하여 인증을 수행.
  - `nonce` 값을 사용하여 요청마다 다르게 해시값을 생성 → 리플레이 공격 방지
  - 다소 복잡하기 때문에 현대 애플리케이션에서는 잘 사용하지 X

#### - WWW-Authenticate / Authorization 헤더의 차이점에 대해서 설명해주세요
1. WWW-Authenticate: 서버 → 클라이언트 (인증 요구)

   : 서버가 먼저 인증을 요구하는 역할. 서버의 응답 헤더에 위치한다.

  - 클라이언트가 인증되지 않았을 때, 서버가 `401 Unauthorized` 응답과 함께 인증 방식을 안내함.
  - 클라이언트가 어떤 방식으로 인증해야 하는지 알려줌.

   [헤더 형식]

    WWW-Authenticate: <type> realm="<realm>"
    

  - `<type>`: 인증 방식 (Basic, Bearer, Digest 등등)
  - `realm=”<realm>”`: 보호된 리소스의 영역(Realm)을 지정함. → 선택사항
2. Authorization: 클라이언트 → 서버 (인증 정보 제공)

   : 클라이언트가 인증 정보를 서버에 제공. 클라이언트의 요청 헤더에 위치한다.

  - 서버가 요구한 인증 방식(Basic, Bearer 등)에 따라 Authorization 헤더를 포함하여 요청.
  - 인증 성공 시에 서버가 정상 응답 (`200 OK`)를 반환.

   [헤더 형식]

    Authorization: <type> <credentials>
    

  - `<type>`: 인증 방식 (Basic, Bearer, Digest, API Key 등등)
  - `<credentials>`: 인증 정보 (Base64 인코딩된 값, JWT 토큰 등등)

#### - JWT가 어떤 구성 요소로 이루어져 있으며, 각 요소의 역할은 무엇인지 설명해주세요

JWT는 .을 구분자로 나누어지는 세 가지 문자열의 조합인데, 아래처럼 3개로 나뉘어 있다.

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9**.**deyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyQ**.**SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

.을 기준으로 가장 맨 처음은 Header, 중간은 Payload, 맨 마지막은 Signature을 의미한다.

Header는 JWT 토큰에서 사용할 타입을 나타내며, 해시 토큰이 담겨있다. “alg”는 서명 암호화 알고리즘이고, 해당 JWT가 어떤 알고리즘을 통해 암호화 되었는지 나타낸다. “typ”는 토큰의 유형을 나타낸다.

Payload는 토큰의 Claim(클레임)을 포함한다. 클레임은 사용자에 대한 정보와 추가 데이터를 포함할 수 있다. 클레임의 종류로는 3가지가 있다. Registered는 미리 정의된 클레임이고, Public은 충돌을 방지하기 위해 IANA JSON Web Token Registry를 통해 정의되거나 URI 형식으로 정의된 클레임이다. Private은 발행자와 수신자 간에 사용하기 위해 정의된 클레임이다.

Signature는 헤더와 페이로드를 인코딩한 후, 주어진 알고리즘을 사용하여 서명된 부분이다. 서명은 토큰의 진위여부를 확인하는 데 사용되고, 서명을 생성하기 위해 다음과 같은 문자열을 만든다.

```
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret
)
```

*참고 링크 : https://maltyy.tistory.com/17

#### - JWT 검증시 서버에서 수행하는 주요 절차에 대해서 설명해주세요
1. 토큰 구조 확인
  - 클라이언트가 보낸 JWT가 올바른 형식을 가지고 있는지 확인.
  - JWT는 `header.payload.signature` 형태의 세 부분으로 구성되어야 함.
2. 서명(Signature) 검증
  - JWT의 서명이 변조되지 않았는지 확인.
  - HMAC, RSA, ECDSA 등의 알고리즘을 사용하여 서명 검증 수행.
3. 토큰 만료 시간(exp) 검증
  - JWT의 exp(만료 시간) 필드를 확인하여 토큰이 유효한지 체크.
4. 발급자(iss) 및 대상(aud) 검증
  - iss(발급자) 필드를 확인하여 신뢰할 수 있는 발급자가 만든 토큰인지 검증.
  - aud(대상) 필드를 검증하여 올바른 대상 서비스에서 요청된 토큰인지 확인.
5. 중복 사용 방지 및 블랙리스트 체크
  - 로그아웃된 토큰 또는 악의적인 공격에 사용된 토큰을 막기 위해 블랙리스트 저장소(Redis 등)에서 조회.
6. 사용자 권한 검증
  - JWT의 `roles`, `scope` 등의 클레임을 활용하여 사용자의 권한을 확인.


#### - Access Token과 Refresh Token 두 토큰의 차이와 각각의 역할, 그리고 토큰 갱신 시 고려해야 할 사항에 대해 설명해 주세요.
1. Access Token
  - 사용자가 인증 되었음을 증명하는 단기 유효 토큰
  - API 요청 시 사용되며, 서버가 클라이언트의 권한을 확인하는 데 필요함.
  - 짧은 유효기간을 가짐. (ex. 15분~60분)
  - 보안 강화를 위해 보통 JWT 형식을 사용.
  - 토큰에 exp(만료시간) 필드가 포함되어 있어서 만료되면 토큰 재발급이 필요하다.
  - 클라이언트 (HTTP 헤더, 메모리)에 저장됨.

   [역할]

  - 사용자의 인증(Authentication) 및 권한(Authorization) 확인
  - 서버가 API 요청을 받을 때, 해당 사용자가 권한이 있는지 확인
  - 토큰이 유효할 동안은 지속적으로 사용 가능

   [문제점]

  - 만료기간이 짦음 → 만료되면 다시 로그인해야 하기 때문에 불편함.
  - 탈취되면 API를 무제한 호출 가능 → 보안 위험! → 이것이 바로 짧은 유효기간이 필요한 이유!
2. Refresh Token
  - 액세스 토큰이 만료되었을 때 새로운 액세스 토큰을 발급하는 용도
  - 서버에서만 저장하고 검증해야 하며, 클라이언트에서는 보관하지 않음.
  - 긴 유효기간을 가짐. (ex. 7일~30일)
  - 보안 강화를 위해 별도의 DB 또는 Redis에서 관리하는 것이 일반적.

   [역할]

  - 사용자가 다시 로그인할 필요 없이 연속적인 인증을 가능하게 함.
  - 보안 강화를 위해 서버 측에서만 저장 및 검증.

   [문제점]

  - 탈취될 경우 장기적인 위험 (만료 기간이 길어 악용될 가능성이 있음)
  - 클라이언트에서는 저장하지 않는 것이 원칙! → DB, Redis 등에서 관리 필요.
3. 토큰 갱신 고려사항

   Access Token이 만료되었을 때 Refresh Token을 사용하여 새로운 Access Token을 발급하는 과정을 고려해야 한다.

  1. Refresh Token 저장 위치
    - 서버에서만 저장해야 함. (클라이언트는 저장 X) → Redis, DB 등에서 안전하게 관리!
    - HTTP-only Secure Cookie를 이용하면 보안성이 향상됨.
  2. Refresh Token 만료 및 보안
    - Refresh Token은 유출될 경우 악용될 가능성이 크므로 1회 사용 후 갱신하는 것이 일반적임.
    - IP 또는 디바이스 정보와 함께 저장하여 다른 환경에서 사용하면 무효화 됨.
    - 로그아웃 시 Refresh Token 폐기 필수
    - 한 번 사용된 Refresh Token은 폐기해야 함. (One-time Token 방식)
  3. 토큰 재발급 흐름 (Token Rotation)

     1️⃣ 사용자가 Access Token을 사용하여 API 요청

     2️⃣ Access Token이 만료되면 401 Unauthorized 응답

     3️⃣ 클라이언트가 Refresh Token을 서버로 전송하여 새로운 Access Token 요청

     4️⃣ 서버가 Refresh Token이 유효한지 확인 후, 새로운 Access Token 발급

     5️⃣ 새 Access Token을 클라이언트에 전달하여 API 요청을 다시 수행

  4. 추가 보안 고려 사항
    - HTTP-Only & Secure 쿠키 사용
      - HTTP-Only: JavaScript에서 접근 불가 (XSS 방지)
      - Secure: HTTPS에서만 사용 가능

#### - 왜 HTTPS가 토큰 기반 인증에서 필수적인지 설명해주세요
1. 토큰 탈취 방지 (Man-in-the-Middle Attack)

   [문제점]

  - HTTP를 사용하면 토큰이 평문으로 전송되기 때문에 공격자가 네트워크 트래픽을 가로채는 중간자 공격을 수행할 수 있음.
  - 공격자는 사용자의 JWT 또는 OAuth Access Token을 흠쳐서 불법적으로 계정에 접근할 수 있음.

   [HTTPS 사용 효과]

  - HTTPS는 TLS 암호화를 사용하여 클라이언트와 서버 간의 통신을 보호함.
  - 네트워크 트래픽을 감청하더라도 공격자는 데이터를 해독할 수 없음.
2. 피싱(Phishing) 공격 방지

   [문제점]

  - HTTP 기반 웹사이트는 피싱 공격에 쉽게 노출됨.
  - 공격자가 사용자로부터 토큰을 훔치기 위해 가짜 로그인 페이지를 만들고, HTTP로 요청을 유도하여 민감한 정보를 탈취할 수 있음.

   [HTTPS 사용 효과]

  - 인증서(Certificate)를 통해 사용자는 신뢰할 수 있는 서버와 통신 중인지 확인 가능.
  - HTTPS를 사용하면 피싱 사이트가 정식 사이트를 발급받기 어려워지고, 브라우저가 “안전하지 않음” 경고를 표시함.
3. 세션 하이재킹 방지

   [문제점]

  - HTTP 환경에서는 토큰이 평문으로 전송되므로, 공격자가 네트워크 트래픽을 감청하고 세션을 가로챌 수 있음.
  - 공격자가 탈취한 토큰을 이용하면 사용자로 가장하여 API 요청을 보낼 수 있음.

   [HTTPS 사용 효과]

  - HTTPS는 데이터 암호화를 통해 세션 토큰이 유출되지 않도록 보호하여, 공격자가 세션을 가로채는 것을 방지함.

#### - (선택) JWT나 OAuth기반 인증에서 발생할 수 있는 보안 취약점 / 이를 보완하기 위한 대책에는 어떤 것들이 있는지 설명해주세요
- JWT의 주요 보안 취약점과 대책
  1. 알고리즘 취약점 (`none` 알고리즘 공격)

     [취약점]

    - JWT는 `alg`(알고리즘) 필드를 이용해 서명 방식을 결정함.
    - 일부 서버는 `alg: none`을 허용하는데, 이 경우 공격자가 서명 없이 JWT를 생성해 위조할 수 있음.

     [해결 방법]

    - 항상 특정 알고리즘을 명시적으로 지정하고, `none` 알고리즘을 허용하지 않도록 설정.
  2. 서명 키(Secret Key) 노출

     [취약점]

    - JWT의 서명 검증을 위한 SECRET_KEY 또는 Private Key가 유출되면 공격자가 토큰을 위조할 수 있음.

     [해결 방법]

    - 비밀키를 환경 변수(.env 파일) 또는 안전한 키 관리 시스템(KMS)에 저장.
    - 공개/비밀키 기반의 RSA(ECDSA) 서명 사용 (RC256, EC256 등).
    - 비밀키를 정기적으로 변경하고 키 회전(Key Rotation) 적용.
  3. 토큰 만료 시간(`exp`) 미설정

     [취약점]

    - `exp`가 없는 JWT는 무제한으로 사용될 수 있음.
    - 탈취된 JWT가 계속 악용될 가능성이 높음.

     [해결 방법]

    - JWT에 `exp` 필드를 반드시 설정.
    - `iat`(발급 시간)과 `nbf`(Not Before) 필드를 추가하여 토큰의 유효기간을 명확히 설정.

<br>

- OAuth 기반 인증의 보안 취약점과 대책
  1. OAuth Redirect URI 취약점 (Open Redirect)

     [취약점]

    - OAuth 로그인 과정에서 `redirect_uri`를 조작하여 악성 사이트로 리다이렉트 가능.
    - 사용자가 피싱 사이트로 유도될 위험이 있음.

     [해결 방법]

    - OAuth 클라이언트 등록 시 `redirect_uri`를 화이트리스트에 등록하여 허용된 도메인만 사용.
  2. OAuth 토큰 탈취

     [취약점]

    - OAuth 2.0 인증 과정에서 인증 코드가 중간자 공격에 의해 탈취될 가능성이 있음.

     [해결 방법]

    - PKCE(Proof Key for Code Exchange) 적용하여 인증 코드 스니핑을 방지.
  3. Access Token 과다 사용 및 보안 부족

     [취약점]

    - Access Token을 장시간 사용하면 탈취 시 보안 위협이 커짐.
    - 권한 범위(scope) 검증이 미흡하면 불필요한 권한을 가진 토큰이 남용될 가능성이 있음.

     [해결 방법]

    - Access Token을 짧게 설정하고, Refresh Token을 사용해 주기적으로 갱신.
    - scope 값을 최소한으로 설정하여 불필요한 권한을 제한.




### Today's Challenges and Solutions

### Daily Retrospective
- 오늘 처음으로 교육장에 나가서 수업을 들어봤는데 아주 상쾌하고 좋았다! 오티할 때 만났던 분이랑 서로 알아봐서
얘기도 많이 하고 점심도 같이 먹었다. 풀스택에는 나랑 다른 한명만 와서 서로 동질감도 느끼면서 꽤나 친해졌다. 
처음이라 그런지 집에서 할 때보다 불편한 점도 있었지만 그래도 집중도 잘되고 좋았다. 일단 교육장이 
엄청 크고 쾌적하니까 좋은 것 같다. 창도 통창이라 안 답답하고 판교 테크노벨리 뷰여서 창 밖의 뷰가 상당히 
예쁘다ㅋㅋ 사람이 아직은 많이 없어서 좋으니까 사람들 많이 안올 때 오프라인으로 자주 오기는 해야겠다!

### References and links
