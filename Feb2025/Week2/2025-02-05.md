# TIL (Today I Learned)

## 날짜: 2025-02-05

### 스크럼
- 어제 한 일 : CLI 과제 마무리(클래스 다이어그램 작성) 및 제출, 이번주 계획 세우기
- 오늘 할 일 : 스레드랑 클래스 아키텍처 키워드 정리, 기술+회고 블로그 작성
- 무드미터 : '편안한' - 어제보다는 덜 피곤한 상태

### 새로 배운 내용
#### 블로킹 / 논블로킹
- **블로킹:** 현재의 작업이 끝나고 다음 작업을 시작하는 것
  - 블로킹은 작업이 순서대로 진행하는 것은 보장하지만 효율성이 떨어진다.
- **논블로킹:** 현재의 작업이 끝나지 않아도 다음 작업을 시작하는 것
  - 논블로킹은 작업의 순서에 상관없이 앞 작업이 끝나지 않아도 각자의 업무를 진행하기 때문에 효율성이 높다.
- 즉, 블로킹과 논블로킹은 서로의 작업에 **차단**을 하는지 안하는지로 구분한다.
- **[제어권 관점에서의 블로킹 / 논블로킹의 차이점]**
  - 블로킹은 제어권을 완전히 넘기는 것이다. 따라서 제어권이 넘어갔기 때문에 다른 작업을 진행할 수 없다. 반면 논블로킹은 제어권을 잠깐 넘겨주지만 바로 돌려 받는다. 따라서 작업이 진행되는 동안에도 백그라운드에서는 다른 작업을 진행할 수 있다.
  - [파일 읽기 작업 예시 설명]
    - 블로킹 방식에서는, 파일 읽는 메소드 호출 시에 제어권이 파일 시스템에게 넘어간다. 따라서 다른 작업을 수행할 수 없고, 파일 읽기가 완료되면 제어권이 반환되어 다음 작업을 할 수 있다.
      논블로킹 방식에서는, 파일 읽는 메소드 호출 시에 제어권을 넘겼다가 실행되면 바로 반환한다. 제어권을 반환받았기 때문에 파일을 읽는 동안 다른 작업을 수행할 수 있다. 파일 읽기가 끝나면 callback을 호출한다.

#### 동기 / 비동기
- **동기:** 현재 작업이 끝나야만 다음 단계의 작업으로 넘어간다.
- **비동기:** 서로의 작업이 독립적으로 진행됨. 작업이 완료되면 서로에게 알림을 준다.
    - 비동기 방식은 작업 완료를 기다리는 시간을 줄이고 CPU 자원을 최대한 활용 가능하다.
- 비동기는 언제 어디서 문제가 생긴 것인지 찾기 어렵다. 따라서 순차적인 작업으로 흐름을 파악해야 할 때는 동기 방식을 사용한다.
- **[동기 / 비동기의 차이]**
    - 동기는 작업의 실행 순서가 보장되며, 프로그램의 흐름을 이해하기가 쉽다. 하지만 작업 시간이 오래 걸릴 수 있다. 반면 비동기는 실행 순서는 보장되지 않지만 CPU 자원의 효율적인 사용과 여러 작업을 동시에 처리할 수 있어서 실시간 처리 시스템에 적합하다.
    - [파일 읽기 작업 예시 설명]
        - 동기 방식으로 파일을 읽으면, 파일을 읽기 시작한 이후에 다음 코드를 실행하지 않고 파일을 다 읽을 때까지 기다린다. 반면 비동기 방식으로 파일을 읽으면 파일을 읽는 작업이 실행되는 동안 다른 작업을 수행할 수 있다. 비동기 방식은 백그라운드에 ‘해당 파일을 읽을 것’이라는 요청만 보내고 바로 다음 작업을 하러 간다. 파일 읽기가 완료되면 백그라운드는 다시 메인 스레드에 읽기가 완료되었음을 알린다.

#### 추가 정리
- **[동기 + 블로킹과 동기 + 논블로킹 조합의 차이]**
    - 동기+블로킹은 제어권과 결과 처리 순서가 동일한 방식이다. 앞 작업이 완전히 끝나야만 다음 작업을 시작할 수 없다. 따라서 각 단계의 결과가 다음 단계의 시작을 결정하게 되고, 제어권도 이 결과 처리를 따라 같이 넘어간다.
    - 동기+논블로킹에서는, 제어권은 작업 실행 후 즉시 반환되고 뒷 작업의 시작은 앞 작업이 결과를 완료하는 시점에 결정된다. 앞 작업은 뒷 작업을 기다리지 않고 계속해서 진행하며, 뒷 작업은 앞 작업을 기다리진 않지만 작업 시작 시점은 앞 작업이 결과를 전달하는 시점에 동기적으로 결정된다.
- **[비동기 I/O와 논블로킹 I/O는 같은 개념인가? 두 개념의 다른 점?]**
    - 비동기 I/O는 I/O 처리가 완료된 타이밍으로 결과를 회신한다. 회신은 시그널 또는 콜백의 형태로 이루어지며 회신이 있을 때까지 다른 작업을 수행할 수 있다. 프로세스가 차단 상태가 되지 않는다는 점에서는 논블로킹 I/O와 같지만, 비동기의 경우 I/O 처리를 완료했을 때 통지를 하고, 처리를 바로할 수 없는 경우 처리가 완료될 때까지 백그라운드에서 대기하고 종료한 타이밍을 화신하는 반면, 논블로킹은 처리가 완료되지 않으면 에러를 회신한다. 논블로킹 I/O는 호출 직후 바로 제어권이 반환되기 때문에 다음 작업을 진행할 수 있다.


### 오늘의 도전 과제와 해결 방법
- 멀티 스레드 환경에서 블로킹 I/O를 사용할때 발생하는 컨텍스트 스위칭 오버헤드를 줄이기 위한 방법은 어떤 것이 있나?
  1. 비동기 I/O 사용
      블로킹 I/O는 스레드가 I/O 작업을 기다리는 동안 아무런 작업도 하지 못하게 되므로, 컨텍스트 스위칭이 빈번하게 발생한다. 따라서 이를 해결하기 위해 비동기 I/O를 활용하면 스레드가 I/O 작업을 기다리는 동안 다른 작업을 수행할 수 있다.
  2. 스레드 개수를 제한하고 스레드를 효율적으로 관리
     스레드가 너무 많으면 컨텍스트 스위칭 오버헤드가 증가하므로, 적절한 스레드 풀의 크기를 설정하여 불필요한 스레드 생성과 삭제를 방지한다. 예를 들어, CPU 개수에 맞는 최적의 스레드 개수를 유지하는 것이 중요하다.

  ***컨텍스트 스위칭 오버헤드**란?
  - CPU가 현재 프로세스/스레드의 상태를 저장하고 다른 프로세스/스레드로 전환될 때 발생하는 비용을 의미함.

  ***멀티 스레드 환경**이란?
  - 멀티 스레드 환경에서는 하나의 프로세스 안에서 여러 스레드를 효율적으로 관리하여 병렬적인 작업 처리가 가능하다. 각 스레드는 프로세스의 리소스를 공유하며 각자 다른 작업을 동시에 진행할 수 있다.

- 웹 서버 아키텍처에서 논블로킹 방식이 주는 성능적 이점은 무엇인가?
  1. 컨텍스트 스위칭 오버헤드 감소 및 리소스의 효율적 사용
  - 블로킹 방식에서는 하나의 요청을 처리하는 동안 I/O가 완료될 때까지 해당 스레드가 대기해야 하고, 다른 요청을 처리하려면 새로운 스레드를 생성해야 함. 스레드가 많아질수록 컨텍스트 스위칭 비용이 증가하여 성능이 저하된다. 반면 논블로킹에서는 이벤트 루프 기반으로 한정된 스레드에서 다수의 요청을 동시에 처리가 가능 → 더 적은 스레드로 더 많은 요청을 효율적으로 처리가 가능하다! 특히 수많은 클라이언트가 연결되는 대규모 트래픽 환경(ex. 채팅 서버, API 서버)에서 강력한 성능을 발휘함.

  2. 빠른 응답 시간과 사용자 경험 향상
  - 블로킹 방식에서는 한 요청이 완료될 때까지 기다려야 하지만, 논블로킹 방식에서는 I/O의 대기 없이 다른 요청을 먼저 처리할 수 있기 때문에 DB 조회, 파일 읽기, 네트워크 요청 등 I/O 작업이 많은 환경에서 큰 장점을 가진다.

  3. 고성능 네트워크 서버에 적합
  - 작업이 완료되지 않아도 제어권을 즉시 반환하고, 호출한 작업이 완료되지 않아도 호출한 스레드는 멈추지 않고 다른 작업을 계속 진행하기 때문에 고성능 네트워크 서버나 멀티태스킹이 필요한 어플리케이션에서 효과적이다.

### 오늘의 회고
- 동기/비동기와 블로킹/논블로킹에 대해서 그동안 단어만 들어보고 제대로 공부해본 적은 없었는데 
이번 기회로 자세하게 배울 수 있어서 좋았다. 여전히 이해가 안가는 부분이 많지만 추가적으로 공부를 하면서
더 알아가야할 것 같다. 케빈이 오늘 배운 개념들은 한번에 이해가 되기 어렵다고 하셨으니 완벽히 이해를 하려면 꾸준히 공부를 해야할 것 같다!
그리고 이해가 되어도 설명하기가 어려운 개념이라고 하니까 여러번 공부를 해봐야겠다.

### 참고 자료 및 링크