# TIL (Today I Learned)

## Date: 2025-02-18 (Day 17)

### Daily Scrum
- [What I did Yesterday] <br>
3주차 과제.. 커뮤니티 하다가 일단 잠 <br>
til 밀린거 약간
- [What to do Today] <br>
3주차 과제 빨리 완성 ㅠㅠ! <br>
til 밀린거 얼른..!!
- [Mood Meter] <br>
  `슬픈`→ 할 게 왜 이렇게 많은지..

### New things I learned
#### Today's Timeline
- 9am-10am: Daily Scrum
- 10am-12pm: WebSocket 강의 & 지난 3주차 복습
- 1pm-4pm: Weekly Challenge
- 4pm-5pm: 팀원들이랑 Keyword 한줄 정리 공유
- 5pm-6pm: 후기 작성 + 마무리
- 6pm-After: 자율 학습

#### Lesson: WebSocket
|  | 정의 | 비고 |
| --- | --- | --- |
| WebSocket | 클라이언트와 서버 간의 **실시간 양방향 통신**을 가능하게 하는 프로토콜 → HTTP와는 다르게 하나의 **연결을 유지**하면서 실시간으로 데이터를 주고 받을 수 있음. | - WebSocket은 HTTP보다 빠르고 효율적인 실시간 양방향 통신을 제공함. <br> - 채팅, 게임, 주식 데이터 등 실시간 애플리케이션에 적합하다. <br> - 사용 방법은 전화를 걸고 끊는 과정과 비슷함. |
| ws와 wss의 차이점 | ws는 비보안 WebSocket을, wss는 보안 WebSocket을 의미한다. → ws는 내부 네트워크에서만 제한적으로 사용해야 하고, 기본적으로는 wss를 사용하는 것이 권장된다. | 웹 소켓을 사용하려면 서버가 HTTPS를 지원해야 wss도 가능하다. <br> (하단 참고) |
| 메시지 프레임과 경계 | 웹 소켓에서 데이터는 프레임으로 나뉘어 전송됨. 웹 소켓의 프레임은 Header+Payload로 구성됨. <br> (하단 참고) | - 이전의 TCP 소켓과는 달리 웹 소켓은 프레임을 명확하게 구분하는 기능을 가지고 있음. <br> (하단 참고) |
| Close 프레임의 역할 | 클라이언트와 서버 간의 연결을 정상적으로 종료하기 위해 사용되는 프레임 | (하단 참고) |

##### - WebSocket

WebSocket은 클라이언트와 서버 간의 **실시간 양방향 통신**을 가능하게 하는 프로토콜 → HTTP처럼 요청-응답 방식이 아니라, 하나의 **연결을 유지**하면서 실시간으로 데이터를 주고 받을 수 있음!

[특징]

- HTTP는 클라이언트가 요청해야 서버가 응답하는 구조이지만, WebSocket은 서버와 클라이언트가 언제든지 데이터를 주고 받을 수 있음.
- HTTP는 요청마다 새 연결을 생성하지만 WebSocket은 한 번 연결하면 유지됨. → 불필요한 연결 생성/해제를 줄여 네트워크 비용을 절감!
- 보안 강화를 위해 `ws://example.com:8000` 보다는 `wss://example.com:8000` 를 사용해야 함.
- 프레임 단위로 데이터를 주고 받음. → 연결을 종료할 때, 서로 Close 프레임을 주고 받으면서 안전하게 연결을 종료시킨다.
- 메시지가 즉시 전달되어야 하는 실시간 채팅 (카카오톡, WhatsApp 등), 다중 플레이어 환경에서 플레이어의 위치나 상태 정보를 실시간으로 동기화 해야 하는 온라인 게임, 초 단위로 주식 가격이 변경되므로 빠른 업데이트가 필요한 주식 시장 데이터 스트리밍 등에서 활용된다.

##### - ws와 wss의 차이점
1. ws:// (WebSocket, 비보안)
    - ws는 기본 웹소켓 프로토콜을 의미하며, 암호화되지 않은 연결을 사용.
    - 일반적인 HTTP(`http://`)와 유사하게 데이터를 평문으로 주고받음.
    - 보안이 필요하지 않은 로컬 개발 환경이나 내부 네트워크(사설망)에서 사용함.
    - 통신 데이터가 암호화되지 않기 때문에 중간자 공격에 취약함
2. ws:// (WebSocket, 보안)
    - wss는 보안 웹소켓 프로토콜로, SSL/ TLS 암호화를 적용한 웹소켓 연결이다.
    - HTTPS(https://)와 마찬가지로 데이터를 암호화하여 전송하므로, 네트워크 스니핑 및 중간자 공격으로부터 안전함.
    - 공개 네트워크(인터넷)에서 사용할 때는 반드시 wss를 사용해야 한다.
    - wss는 HTTPS가 활성화된 서버에서만 동작하며, SSL/TLS 인증서를 요구함.
3. 차이점 정리

|  | ws:// (비보안 WebSocket) | wss:// (보안 WebSocket) |
| --- | --- | --- |
| 암호화 | 없음 (평문 전송) | SSL/TLS 암호화 |
| 보안 수준 | 낮음 (중간자 공격, 패킷 스니핑 위험) | 높음 → 암호화로 데이터 보호 |
| 사용 환경 | 내부 네트워크(사설망), 로컬 개발(`localhost` 테스트) | 인터넷에 연결된 모든 서비스, 민감한 데이터 전송 |
| 포트 번호 | 80 (기본 HTTP와 동일) | 443 (기본 HTTPS와 동일) |
| 주요 위험 | MITM 공격, 도청, 변조 | 없음 (SSL/TLS 보호) |

##### - 메세지 프레임과 경계

웹 소켓은 프레임 단위로 데이터를 주고 받는 프로토콜이며, 메세지 프레임과 경계가 중요한 개념이다.

- 메시지 프레임 덕분에 데이터 패킷을 조각내어 전송 가능 → 더 효율적인 데이터 전송
- 메시지 경계를 사용하면 데이터를 안전하게 조립 가능 → 끊기지 않는 스트리밍 구현 가능
- 다중 프레임 전송 덕분에 대용량 데이터(동영상, 파일 등)도 WebSocket에서 처리 가능

[메세지 프레임이란?]

- 웹 소켓에서 데이터는 작은 조각인 프레임으로 나뉘어 전송되며, 이전의 TCP 소켓과는 달리, 웹 소켓은 프레임을 명확하게 구분하는 기능을 가지고 있다.
- 웹 소켓의 프레임은 Header + Payload로 구성된다.

[WebSocket 메시지 경계]

메시지 경계는 하나의 완전한 메시지가 어디서 시작되고 끝나는지를 정의하는 개념이다. 즉, 클라이언트와 서버가 주고 받는 메시지 단위를 명확하게 구분하는 역할을 한다.

- FIN (종료 비트, Final Bit]

  웹 소켓에서는 FIN 비트를 사용해 하나의 메시지가 끝나는 위치를 지정한다.

    - `FIN = 1` → 현재 프레임이 메시지의 마지막 조각임.
    - `FIN = 0` → 메시지가 여러 개의 프레임으로 나뉘어 전송됨. (후속 프레임이 존재함.)

  [메시지가 하나의 프레임으로 전송되는 경우 (단일 프레임 메시지)]

    ```java
    +--------+-----------+
    | FIN=1  |  Payload  |
    +--------+-----------+
    ```

  → 하나의 메시지가 단일 프레임으로 전송됨.

  → `FIN = 1` 이므로 메시지 경계가 명확함.

  [메시지가 여러 개의 프레임으로 분할되어 전송되는 경우 (다중 프레임 메시지)]

    ```java
    +--------+-----------+
    | FIN=0  |  Payload  |  (첫 번째 프레임)
    +--------+-----------+
    
    +--------+-----------+
    | FIN=0  |  Payload  |  (중간 프레임)
    +--------+-----------+
    
    +--------+-----------+
    | FIN=1  |  Payload  |  (마지막 프레임)
    +--------+-----------+
    ```

  → 첫 번째 프레임(`FIN = 0`), 중간 프레임 (`FIN = 0`), 마지막 프레임 (`FIN = 1`)로 나뉘어 전송됨.

  → 메시지 경계를 통해 서버가 메시지를 올바르게 조합할 수 있게 된다.


##### - Close 프레임의 역할

웹 소켓의 Close 프레임(Opcode = 0x8)은 클라이언트와 서버 간의 연결을 정상적으로 종료하기 위해 사용되는 프레임이다.

- 웹 소켓은 HTTP처럼 요청-응답 방식이 아니라, 연결을 지속하는 프로토콜이기 때문에 연결을 종료할 때 반드시 Close 프레임을 주고 받아야 함.
- 양쪽이 Close 프레임을 주고 받아야 연결이 완전히 안전하게 종료됨.
- 상태코드(Status Code)를 통해 종료 이유를 전달할 수 있다.

[Close 프레임의 데이터 구조]

| 필드 | 크기 | 설명 |
| --- | --- | --- |
| **Opcode** | 4bit | `0x8` (Close Frame) |
| **Status Code** | 2byte | 종료 이유를 나타내는 상태 코드 |
| **Reason (Optional)** | 가변 길이 | 종료 사유를 설명하는 UTF-8 문자열 (선택적) |

📌 Close 프레임 예제 (바이너리 데이터)

```jsx
+--------+----------+-------------------+
| 0x8    | 1000     | "Normal Closure"  |
+--------+----------+-------------------+
```

- Opcode `0x8` → Close Frame
- 상태 코드 `1000` → 정상 종료
- 이유 `"Normal Closure"` (선택적)

[Close 프레임의 상태 코드(Status Code)]

WebSocket Close 프레임에는 종료 이유를 나타내는 상태 코드(Status Code, 2바이트) 를 포함할 수 있음.

📌 주요 WebSocket 상태 코드

| 상태 코드 | 의미 | 설명 |
| --- | --- | --- |
| `1000` | Normal Closure | 정상적인 종료 |
| `1001` | Going Away | 서버가 다운되거나 종료됨 |
| `1002` | Protocol Error | 프로토콜 오류 발생 |
| `1003` | Unsupported Data | 지원하지 않는 데이터 유형 전송됨 |
| `1006` | Abnormal Closure | Close 프레임 없이 연결이 끊어짐 (네트워크 오류 등) |
| `1007` | Invalid Data | UTF-8 데이터 형식 오류 |
| `1008` | Policy Violation | 보안 정책 위반 |
| `1011` | Internal Server Error | 서버 내부 오류 발생 |

🚨 주의: `1006`(Abnormal Closure)은 실제 전송되지 않고, 연결이 비정상적으로 끊어졌을 때 WebSocket API에서 감지됨.


### Today's Challenges and Solutions

### Daily Retrospective
- 저번주부터 키워드 정리랑 과제가 계속 많이 밀리고 있어서 상당히 불안하고 마음도 불편한 상태다.. 
얼른 밀린 걸 해치우고 싶은데 시간은 부족하고 그래서 많이 스트레스를 받는 상태임..!!! 으악 
정보와 할 일의 홍수에서 허우적 대고 있는 나자신...

### References and links